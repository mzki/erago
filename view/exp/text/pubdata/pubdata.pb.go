// Code generated by protoc-gen-go-lite. DO NOT EDIT.
// protoc-gen-go-lite version: v0.10.0
// source: view/exp/text/pubdata/pubdata.proto

package pubdata

import (
	fmt "fmt"
	protobuf_go_lite "github.com/aperturerobotics/protobuf-go-lite"
	json "github.com/aperturerobotics/protobuf-go-lite/json"
	io "io"
	strconv "strconv"
)

// package pubdata intended for exporting data structure for
// other platforms such as mobile, wasm and so on.
// All of type of exported struct field and function signature should be
// restricted by the restriction of platform conversion.
// e.g. mobile type restrinction is found at
// https://pkg.go.dev/golang.org/x/mobile/cmd/gobind?utm_source=godoc#hdr-Type_restrictions

type ContentType int32

const (
	ContentType_CONTENT_TYPE_UNKNOWN     ContentType = 0
	ContentType_CONTENT_TYPE_TEXT        ContentType = 1
	ContentType_CONTENT_TYPE_TEXT_BUTTON ContentType = 2
	ContentType_CONTENT_TYPE_IMAGE       ContentType = 3
	ContentType_CONTENT_TYPE_SPACE       ContentType = 4
)

// Enum value maps for ContentType.
var (
	ContentType_name = map[int32]string{
		0: "CONTENT_TYPE_UNKNOWN",
		1: "CONTENT_TYPE_TEXT",
		2: "CONTENT_TYPE_TEXT_BUTTON",
		3: "CONTENT_TYPE_IMAGE",
		4: "CONTENT_TYPE_SPACE",
	}
	ContentType_value = map[string]int32{
		"CONTENT_TYPE_UNKNOWN":     0,
		"CONTENT_TYPE_TEXT":        1,
		"CONTENT_TYPE_TEXT_BUTTON": 2,
		"CONTENT_TYPE_IMAGE":       3,
		"CONTENT_TYPE_SPACE":       4,
	}
)

func (x ContentType) Enum() *ContentType {
	p := new(ContentType)
	*p = x
	return p
}

func (x ContentType) String() string {
	name, valid := ContentType_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type Alignment int32

const (
	Alignment_ALIGNMENT_UNKNOWN Alignment = 0
	Alignment_ALIGNMENT_LEFT    Alignment = 1
	Alignment_ALIGNMENT_CENTER  Alignment = 2
	Alignment_ALIGNMENT_RIGHT   Alignment = 3
)

// Enum value maps for Alignment.
var (
	Alignment_name = map[int32]string{
		0: "ALIGNMENT_UNKNOWN",
		1: "ALIGNMENT_LEFT",
		2: "ALIGNMENT_CENTER",
		3: "ALIGNMENT_RIGHT",
	}
	Alignment_value = map[string]int32{
		"ALIGNMENT_UNKNOWN": 0,
		"ALIGNMENT_LEFT":    1,
		"ALIGNMENT_CENTER":  2,
		"ALIGNMENT_RIGHT":   3,
	}
)

func (x Alignment) Enum() *Alignment {
	p := new(Alignment)
	*p = x
	return p
}

func (x Alignment) String() string {
	name, valid := Alignment_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// ImageFetchType indicates how image pixels to be included in ImageData.Data.
// This type is aliases for int since it may be encoded to the json format.
type ImageFetchType int32

const (
	ImageFetchType_IMAGE_FETCH_TYPE_UNKNOWN ImageFetchType = 0
	// ImageFetchTypeNone indicates no image pixel data in ImageData.
	// Client use URI of image to fetch pixels manually.
	ImageFetchType_IMAGE_FETCH_TYPE_NONE ImageFetchType = 1
	// ImageFetchRawRGBA indicates image pixels stored in raw RGBA bytes in
	// ImageData.
	ImageFetchType_IMAGE_FETCH_TYPE_RAW_RGBA ImageFetchType = 2
	// ImageFetchEncodedPNG indicates image pixels stored in png encoded bytes in
	// ImageData.
	ImageFetchType_IMAGE_FETCH_TYPE_ENCODED_PNG ImageFetchType = 3
)

// Enum value maps for ImageFetchType.
var (
	ImageFetchType_name = map[int32]string{
		0: "IMAGE_FETCH_TYPE_UNKNOWN",
		1: "IMAGE_FETCH_TYPE_NONE",
		2: "IMAGE_FETCH_TYPE_RAW_RGBA",
		3: "IMAGE_FETCH_TYPE_ENCODED_PNG",
	}
	ImageFetchType_value = map[string]int32{
		"IMAGE_FETCH_TYPE_UNKNOWN":     0,
		"IMAGE_FETCH_TYPE_NONE":        1,
		"IMAGE_FETCH_TYPE_RAW_RGBA":    2,
		"IMAGE_FETCH_TYPE_ENCODED_PNG": 3,
	}
)

func (x ImageFetchType) Enum() *ImageFetchType {
	p := new(ImageFetchType)
	*p = x
	return p
}

func (x ImageFetchType) String() string {
	name, valid := ImageFetchType_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// Paragraph is a block of content divided by hard return (\n).
type Paragraph struct {
	unknownFields []byte
	Id            int64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Lines         []*Line   `protobuf:"bytes,2,rep,name=lines,proto3" json:"lines,omitempty"`
	Alignment     Alignment `protobuf:"varint,3,opt,name=alignment,proto3" json:"alignment,omitempty"`
	Fixed         bool      `protobuf:"varint,4,opt,name=fixed,proto3" json:"fixed,omitempty"`
}

func (x *Paragraph) Reset() {
	*x = Paragraph{}
}

func (*Paragraph) ProtoMessage() {}

func (x *Paragraph) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Paragraph) GetLines() []*Line {
	if x != nil {
		return x.Lines
	}
	return nil
}

func (x *Paragraph) GetAlignment() Alignment {
	if x != nil {
		return x.Alignment
	}
	return Alignment_ALIGNMENT_UNKNOWN
}

func (x *Paragraph) GetFixed() bool {
	if x != nil {
		return x.Fixed
	}
	return false
}

// Line is a line in view window.
type Line struct {
	unknownFields []byte
	Boxes         []*Box `protobuf:"bytes,1,rep,name=boxes,proto3" json:"boxes,omitempty"`
	RuneWidth     int32  `protobuf:"varint,2,opt,name=rune_width,json=runeWidth,proto3" json:"runeWidth,omitempty"`
}

func (x *Line) Reset() {
	*x = Line{}
}

func (*Line) ProtoMessage() {}

func (x *Line) GetBoxes() []*Box {
	if x != nil {
		return x.Boxes
	}
	return nil
}

func (x *Line) GetRuneWidth() int32 {
	if x != nil {
		return x.RuneWidth
	}
	return 0
}

// Box is abstract content. It holds nomal text, unsplitable text and images and so on.
// The Box is the smallest element for whole content.
// The whole content consist with multiple Paragraph-s, which is divided by the hard return (\n).
// Paragraph consist with multiple Line-s, which is divided by rune width in the maximum width in
// the view window. The Line consists with multiple Box-s, which is divided by its attributes.
//
// The Box type can be validated by type assertion or ContentType().
type Box struct {
	unknownFields []byte
	RuneWidth     int32       `protobuf:"varint,1,opt,name=rune_width,json=runeWidth,proto3" json:"runeWidth,omitempty"`              // box's width in runewidth.
	LineCountHint int32       `protobuf:"varint,2,opt,name=line_count_hint,json=lineCountHint,proto3" json:"lineCountHint,omitempty"` // box's height hint, typically 1 but sometimes larger than 1.
	ContentType   ContentType `protobuf:"varint,3,opt,name=content_type,json=contentType,proto3" json:"contentType,omitempty"`        // box's content type
	// Types that are assignable to Data:
	//
	//	*Box_TextData
	//	*Box_TextButtonData
	//	*Box_ImageData
	//	*Box_SpaceData
	Data isBox_Data `protobuf_oneof:"data"`
}

func (x *Box) Reset() {
	*x = Box{}
}

func (*Box) ProtoMessage() {}

func (x *Box) GetRuneWidth() int32 {
	if x != nil {
		return x.RuneWidth
	}
	return 0
}

func (x *Box) GetLineCountHint() int32 {
	if x != nil {
		return x.LineCountHint
	}
	return 0
}

func (x *Box) GetContentType() ContentType {
	if x != nil {
		return x.ContentType
	}
	return ContentType_CONTENT_TYPE_UNKNOWN
}

func (m *Box) GetData() isBox_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (x *Box) GetTextData() *TextData {
	if x, ok := x.GetData().(*Box_TextData); ok {
		return x.TextData
	}
	return nil
}

func (x *Box) GetTextButtonData() *TextButtonData {
	if x, ok := x.GetData().(*Box_TextButtonData); ok {
		return x.TextButtonData
	}
	return nil
}

func (x *Box) GetImageData() *ImageData {
	if x, ok := x.GetData().(*Box_ImageData); ok {
		return x.ImageData
	}
	return nil
}

func (x *Box) GetSpaceData() *SpaceData {
	if x, ok := x.GetData().(*Box_SpaceData); ok {
		return x.SpaceData
	}
	return nil
}

type isBox_Data interface {
	isBox_Data()
}

type Box_TextData struct {
	TextData *TextData `protobuf:"bytes,9,opt,name=text_data,json=textData,proto3,oneof"`
}

type Box_TextButtonData struct {
	TextButtonData *TextButtonData `protobuf:"bytes,10,opt,name=text_button_data,json=textButtonData,proto3,oneof"`
}

type Box_ImageData struct {
	ImageData *ImageData `protobuf:"bytes,11,opt,name=image_data,json=imageData,proto3,oneof"`
}

type Box_SpaceData struct {
	SpaceData *SpaceData `protobuf:"bytes,12,opt,name=space_data,json=spaceData,proto3,oneof"`
}

func (*Box_TextData) isBox_Data() {}

func (*Box_TextButtonData) isBox_Data() {}

func (*Box_ImageData) isBox_Data() {}

func (*Box_SpaceData) isBox_Data() {}

// TextData is data for ContentTypeText.
type TextData struct {
	unknownFields []byte
	// text content should not contain hard return.
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	// Foreground color represents 32bit RGB used to font face color
	Fgcolor int32 `protobuf:"varint,2,opt,name=fgcolor,proto3" json:"fgcolor,omitempty"`
	// Background color represents 32bit RGB used to background on text.
	Bgcolor int32 `protobuf:"varint,3,opt,name=bgcolor,proto3" json:"bgcolor,omitempty"`
}

func (x *TextData) Reset() {
	*x = TextData{}
}

func (*TextData) ProtoMessage() {}

func (x *TextData) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

func (x *TextData) GetFgcolor() int32 {
	if x != nil {
		return x.Fgcolor
	}
	return 0
}

func (x *TextData) GetBgcolor() int32 {
	if x != nil {
		return x.Bgcolor
	}
	return 0
}

// TextButtonData is data for ContentTypeTextButton.
type TextButtonData struct {
	unknownFields []byte
	TextData      *TextData `protobuf:"bytes,1,opt,name=text_data,json=textData,proto3" json:"textData,omitempty"`
	Command       string    `protobuf:"bytes,2,opt,name=command,proto3" json:"command,omitempty"`
}

func (x *TextButtonData) Reset() {
	*x = TextButtonData{}
}

func (*TextButtonData) ProtoMessage() {}

func (x *TextButtonData) GetTextData() *TextData {
	if x != nil {
		return x.TextData
	}
	return nil
}

func (x *TextButtonData) GetCommand() string {
	if x != nil {
		return x.Command
	}
	return ""
}

// ImageData is data for ContentTypeImage.
type ImageData struct {
	unknownFields   []byte
	Source          string         `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	WidthPx         int32          `protobuf:"varint,2,opt,name=width_px,json=widthPx,proto3" json:"widthPx,omitempty"`
	HeightPx        int32          `protobuf:"varint,3,opt,name=height_px,json=heightPx,proto3" json:"heightPx,omitempty"`
	WidthTextScale  int32          `protobuf:"varint,4,opt,name=width_text_scale,json=widthTextScale,proto3" json:"widthTextScale,omitempty"`
	HeightTextScale int32          `protobuf:"varint,5,opt,name=height_text_scale,json=heightTextScale,proto3" json:"heightTextScale,omitempty"`
	Data            []byte         `protobuf:"bytes,10,opt,name=data,proto3" json:"data,omitempty"`
	DataFetchType   ImageFetchType `protobuf:"varint,11,opt,name=data_fetch_type,json=dataFetchType,proto3" json:"dataFetchType,omitempty"`
}

func (x *ImageData) Reset() {
	*x = ImageData{}
}

func (*ImageData) ProtoMessage() {}

func (x *ImageData) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *ImageData) GetWidthPx() int32 {
	if x != nil {
		return x.WidthPx
	}
	return 0
}

func (x *ImageData) GetHeightPx() int32 {
	if x != nil {
		return x.HeightPx
	}
	return 0
}

func (x *ImageData) GetWidthTextScale() int32 {
	if x != nil {
		return x.WidthTextScale
	}
	return 0
}

func (x *ImageData) GetHeightTextScale() int32 {
	if x != nil {
		return x.HeightTextScale
	}
	return 0
}

func (x *ImageData) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *ImageData) GetDataFetchType() ImageFetchType {
	if x != nil {
		return x.DataFetchType
	}
	return ImageFetchType_IMAGE_FETCH_TYPE_UNKNOWN
}

// SpaceBox holds space data.
type SpaceData struct {
	unknownFields []byte
	// There is a protoc plugin which could not handle empty message properly.
	// To avoid the issue, we need to add concrete field instead of reserved feature in protobuf spec
	Reserved bool `protobuf:"varint,1,opt,name=reserved,proto3" json:"reserved,omitempty"`
}

func (x *SpaceData) Reset() {
	*x = SpaceData{}
}

func (*SpaceData) ProtoMessage() {}

func (x *SpaceData) GetReserved() bool {
	if x != nil {
		return x.Reserved
	}
	return false
}

func (this *Paragraph) EqualVT(that *Paragraph) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Id != that.Id {
		return false
	}
	if len(this.Lines) != len(that.Lines) {
		return false
	}
	for i, vx := range this.Lines {
		vy := that.Lines[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Line{}
			}
			if q == nil {
				q = &Line{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.Alignment != that.Alignment {
		return false
	}
	if this.Fixed != that.Fixed {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Paragraph) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Paragraph)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Line) EqualVT(that *Line) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Boxes) != len(that.Boxes) {
		return false
	}
	for i, vx := range this.Boxes {
		vy := that.Boxes[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Box{}
			}
			if q == nil {
				q = &Box{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.RuneWidth != that.RuneWidth {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Line) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Line)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Box) EqualVT(that *Box) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Data == nil && that.Data != nil {
		return false
	} else if this.Data != nil {
		if that.Data == nil {
			return false
		}
		if !this.Data.(interface{ EqualVT(isBox_Data) bool }).EqualVT(that.Data) {
			return false
		}
	}
	if this.RuneWidth != that.RuneWidth {
		return false
	}
	if this.LineCountHint != that.LineCountHint {
		return false
	}
	if this.ContentType != that.ContentType {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Box) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Box)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Box_TextData) EqualVT(thatIface isBox_Data) bool {
	that, ok := thatIface.(*Box_TextData)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.TextData, that.TextData; p != q {
		if p == nil {
			p = &TextData{}
		}
		if q == nil {
			q = &TextData{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *Box_TextButtonData) EqualVT(thatIface isBox_Data) bool {
	that, ok := thatIface.(*Box_TextButtonData)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.TextButtonData, that.TextButtonData; p != q {
		if p == nil {
			p = &TextButtonData{}
		}
		if q == nil {
			q = &TextButtonData{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *Box_ImageData) EqualVT(thatIface isBox_Data) bool {
	that, ok := thatIface.(*Box_ImageData)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.ImageData, that.ImageData; p != q {
		if p == nil {
			p = &ImageData{}
		}
		if q == nil {
			q = &ImageData{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *Box_SpaceData) EqualVT(thatIface isBox_Data) bool {
	that, ok := thatIface.(*Box_SpaceData)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.SpaceData, that.SpaceData; p != q {
		if p == nil {
			p = &SpaceData{}
		}
		if q == nil {
			q = &SpaceData{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *TextData) EqualVT(that *TextData) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Text != that.Text {
		return false
	}
	if this.Fgcolor != that.Fgcolor {
		return false
	}
	if this.Bgcolor != that.Bgcolor {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *TextData) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*TextData)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *TextButtonData) EqualVT(that *TextButtonData) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.TextData.EqualVT(that.TextData) {
		return false
	}
	if this.Command != that.Command {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *TextButtonData) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*TextButtonData)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ImageData) EqualVT(that *ImageData) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Source != that.Source {
		return false
	}
	if this.WidthPx != that.WidthPx {
		return false
	}
	if this.HeightPx != that.HeightPx {
		return false
	}
	if this.WidthTextScale != that.WidthTextScale {
		return false
	}
	if this.HeightTextScale != that.HeightTextScale {
		return false
	}
	if string(this.Data) != string(that.Data) {
		return false
	}
	if this.DataFetchType != that.DataFetchType {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ImageData) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ImageData)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SpaceData) EqualVT(that *SpaceData) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Reserved != that.Reserved {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SpaceData) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*SpaceData)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

// MarshalProtoJSON marshals the ContentType to JSON.
func (x ContentType) MarshalProtoJSON(s *json.MarshalState) {
	s.WriteEnum(int32(x), ContentType_name)
}

// MarshalText marshals the ContentType to text.
func (x ContentType) MarshalText() ([]byte, error) {
	return []byte(json.GetEnumString(int32(x), ContentType_name)), nil
}

// MarshalJSON marshals the ContentType to JSON.
func (x ContentType) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ContentType from JSON.
func (x *ContentType) UnmarshalProtoJSON(s *json.UnmarshalState) {
	v := s.ReadEnum(ContentType_value)
	if err := s.Err(); err != nil {
		s.SetErrorf("could not read ContentType enum: %v", err)
		return
	}
	*x = ContentType(v)
}

// UnmarshalText unmarshals the ContentType from text.
func (x *ContentType) UnmarshalText(b []byte) error {
	i, err := json.ParseEnumString(string(b), ContentType_value)
	if err != nil {
		return err
	}
	*x = ContentType(i)
	return nil
}

// UnmarshalJSON unmarshals the ContentType from JSON.
func (x *ContentType) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Alignment to JSON.
func (x Alignment) MarshalProtoJSON(s *json.MarshalState) {
	s.WriteEnum(int32(x), Alignment_name)
}

// MarshalText marshals the Alignment to text.
func (x Alignment) MarshalText() ([]byte, error) {
	return []byte(json.GetEnumString(int32(x), Alignment_name)), nil
}

// MarshalJSON marshals the Alignment to JSON.
func (x Alignment) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Alignment from JSON.
func (x *Alignment) UnmarshalProtoJSON(s *json.UnmarshalState) {
	v := s.ReadEnum(Alignment_value)
	if err := s.Err(); err != nil {
		s.SetErrorf("could not read Alignment enum: %v", err)
		return
	}
	*x = Alignment(v)
}

// UnmarshalText unmarshals the Alignment from text.
func (x *Alignment) UnmarshalText(b []byte) error {
	i, err := json.ParseEnumString(string(b), Alignment_value)
	if err != nil {
		return err
	}
	*x = Alignment(i)
	return nil
}

// UnmarshalJSON unmarshals the Alignment from JSON.
func (x *Alignment) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ImageFetchType to JSON.
func (x ImageFetchType) MarshalProtoJSON(s *json.MarshalState) {
	s.WriteEnum(int32(x), ImageFetchType_name)
}

// MarshalText marshals the ImageFetchType to text.
func (x ImageFetchType) MarshalText() ([]byte, error) {
	return []byte(json.GetEnumString(int32(x), ImageFetchType_name)), nil
}

// MarshalJSON marshals the ImageFetchType to JSON.
func (x ImageFetchType) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ImageFetchType from JSON.
func (x *ImageFetchType) UnmarshalProtoJSON(s *json.UnmarshalState) {
	v := s.ReadEnum(ImageFetchType_value)
	if err := s.Err(); err != nil {
		s.SetErrorf("could not read ImageFetchType enum: %v", err)
		return
	}
	*x = ImageFetchType(v)
}

// UnmarshalText unmarshals the ImageFetchType from text.
func (x *ImageFetchType) UnmarshalText(b []byte) error {
	i, err := json.ParseEnumString(string(b), ImageFetchType_value)
	if err != nil {
		return err
	}
	*x = ImageFetchType(i)
	return nil
}

// UnmarshalJSON unmarshals the ImageFetchType from JSON.
func (x *ImageFetchType) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Paragraph message to JSON.
func (x *Paragraph) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Id != 0 || s.HasField("id") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("id")
		s.WriteInt64(x.Id)
	}
	if len(x.Lines) > 0 || s.HasField("lines") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("lines")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Lines {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("lines"))
		}
		s.WriteArrayEnd()
	}
	if x.Alignment != 0 || s.HasField("alignment") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("alignment")
		x.Alignment.MarshalProtoJSON(s)
	}
	if x.Fixed || s.HasField("fixed") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("fixed")
		s.WriteBool(x.Fixed)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Paragraph to JSON.
func (x *Paragraph) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Paragraph message from JSON.
func (x *Paragraph) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "id":
			s.AddField("id")
			x.Id = s.ReadInt64()
		case "lines":
			s.AddField("lines")
			if s.ReadNil() {
				x.Lines = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Lines = append(x.Lines, nil)
					return
				}
				v := &Line{}
				v.UnmarshalProtoJSON(s.WithField("lines", false))
				if s.Err() != nil {
					return
				}
				x.Lines = append(x.Lines, v)
			})
		case "alignment":
			s.AddField("alignment")
			x.Alignment.UnmarshalProtoJSON(s)
		case "fixed":
			s.AddField("fixed")
			x.Fixed = s.ReadBool()
		}
	})
}

// UnmarshalJSON unmarshals the Paragraph from JSON.
func (x *Paragraph) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Line message to JSON.
func (x *Line) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.Boxes) > 0 || s.HasField("boxes") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("boxes")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Boxes {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("boxes"))
		}
		s.WriteArrayEnd()
	}
	if x.RuneWidth != 0 || s.HasField("runeWidth") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("runeWidth")
		s.WriteInt32(x.RuneWidth)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Line to JSON.
func (x *Line) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Line message from JSON.
func (x *Line) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "boxes":
			s.AddField("boxes")
			if s.ReadNil() {
				x.Boxes = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Boxes = append(x.Boxes, nil)
					return
				}
				v := &Box{}
				v.UnmarshalProtoJSON(s.WithField("boxes", false))
				if s.Err() != nil {
					return
				}
				x.Boxes = append(x.Boxes, v)
			})
		case "rune_width", "runeWidth":
			s.AddField("rune_width")
			x.RuneWidth = s.ReadInt32()
		}
	})
}

// UnmarshalJSON unmarshals the Line from JSON.
func (x *Line) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Box message to JSON.
func (x *Box) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.RuneWidth != 0 || s.HasField("runeWidth") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("runeWidth")
		s.WriteInt32(x.RuneWidth)
	}
	if x.LineCountHint != 0 || s.HasField("lineCountHint") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("lineCountHint")
		s.WriteInt32(x.LineCountHint)
	}
	if x.ContentType != 0 || s.HasField("contentType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("contentType")
		x.ContentType.MarshalProtoJSON(s)
	}
	if x.Data != nil {
		switch ov := x.Data.(type) {
		case *Box_TextData:
			s.WriteMoreIf(&wroteField)
			s.WriteObjectField("textData")
			ov.TextData.MarshalProtoJSON(s.WithField("textData"))
		case *Box_TextButtonData:
			s.WriteMoreIf(&wroteField)
			s.WriteObjectField("textButtonData")
			ov.TextButtonData.MarshalProtoJSON(s.WithField("textButtonData"))
		case *Box_ImageData:
			s.WriteMoreIf(&wroteField)
			s.WriteObjectField("imageData")
			ov.ImageData.MarshalProtoJSON(s.WithField("imageData"))
		case *Box_SpaceData:
			s.WriteMoreIf(&wroteField)
			s.WriteObjectField("spaceData")
			ov.SpaceData.MarshalProtoJSON(s.WithField("spaceData"))
		}
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Box to JSON.
func (x *Box) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Box message from JSON.
func (x *Box) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "rune_width", "runeWidth":
			s.AddField("rune_width")
			x.RuneWidth = s.ReadInt32()
		case "line_count_hint", "lineCountHint":
			s.AddField("line_count_hint")
			x.LineCountHint = s.ReadInt32()
		case "content_type", "contentType":
			s.AddField("content_type")
			x.ContentType.UnmarshalProtoJSON(s)
		case "text_data", "textData":
			ov := &Box_TextData{}
			x.Data = ov
			if s.ReadNil() {
				ov.TextData = nil
				return
			}
			ov.TextData = &TextData{}
			ov.TextData.UnmarshalProtoJSON(s.WithField("text_data", true))
		case "text_button_data", "textButtonData":
			ov := &Box_TextButtonData{}
			x.Data = ov
			if s.ReadNil() {
				ov.TextButtonData = nil
				return
			}
			ov.TextButtonData = &TextButtonData{}
			ov.TextButtonData.UnmarshalProtoJSON(s.WithField("text_button_data", true))
		case "image_data", "imageData":
			ov := &Box_ImageData{}
			x.Data = ov
			if s.ReadNil() {
				ov.ImageData = nil
				return
			}
			ov.ImageData = &ImageData{}
			ov.ImageData.UnmarshalProtoJSON(s.WithField("image_data", true))
		case "space_data", "spaceData":
			ov := &Box_SpaceData{}
			x.Data = ov
			if s.ReadNil() {
				ov.SpaceData = nil
				return
			}
			ov.SpaceData = &SpaceData{}
			ov.SpaceData.UnmarshalProtoJSON(s.WithField("space_data", true))
		}
	})
}

// UnmarshalJSON unmarshals the Box from JSON.
func (x *Box) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the TextData message to JSON.
func (x *TextData) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Text != "" || s.HasField("text") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("text")
		s.WriteString(x.Text)
	}
	if x.Fgcolor != 0 || s.HasField("fgcolor") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("fgcolor")
		s.WriteInt32(x.Fgcolor)
	}
	if x.Bgcolor != 0 || s.HasField("bgcolor") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("bgcolor")
		s.WriteInt32(x.Bgcolor)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the TextData to JSON.
func (x *TextData) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the TextData message from JSON.
func (x *TextData) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "text":
			s.AddField("text")
			x.Text = s.ReadString()
		case "fgcolor":
			s.AddField("fgcolor")
			x.Fgcolor = s.ReadInt32()
		case "bgcolor":
			s.AddField("bgcolor")
			x.Bgcolor = s.ReadInt32()
		}
	})
}

// UnmarshalJSON unmarshals the TextData from JSON.
func (x *TextData) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the TextButtonData message to JSON.
func (x *TextButtonData) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.TextData != nil || s.HasField("textData") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("textData")
		x.TextData.MarshalProtoJSON(s.WithField("textData"))
	}
	if x.Command != "" || s.HasField("command") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("command")
		s.WriteString(x.Command)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the TextButtonData to JSON.
func (x *TextButtonData) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the TextButtonData message from JSON.
func (x *TextButtonData) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "text_data", "textData":
			if s.ReadNil() {
				x.TextData = nil
				return
			}
			x.TextData = &TextData{}
			x.TextData.UnmarshalProtoJSON(s.WithField("text_data", true))
		case "command":
			s.AddField("command")
			x.Command = s.ReadString()
		}
	})
}

// UnmarshalJSON unmarshals the TextButtonData from JSON.
func (x *TextButtonData) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ImageData message to JSON.
func (x *ImageData) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Source != "" || s.HasField("source") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("source")
		s.WriteString(x.Source)
	}
	if x.WidthPx != 0 || s.HasField("widthPx") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("widthPx")
		s.WriteInt32(x.WidthPx)
	}
	if x.HeightPx != 0 || s.HasField("heightPx") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("heightPx")
		s.WriteInt32(x.HeightPx)
	}
	if x.WidthTextScale != 0 || s.HasField("widthTextScale") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("widthTextScale")
		s.WriteInt32(x.WidthTextScale)
	}
	if x.HeightTextScale != 0 || s.HasField("heightTextScale") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("heightTextScale")
		s.WriteInt32(x.HeightTextScale)
	}
	if len(x.Data) > 0 || s.HasField("data") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("data")
		s.WriteBytes(x.Data)
	}
	if x.DataFetchType != 0 || s.HasField("dataFetchType") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("dataFetchType")
		x.DataFetchType.MarshalProtoJSON(s)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ImageData to JSON.
func (x *ImageData) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ImageData message from JSON.
func (x *ImageData) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "source":
			s.AddField("source")
			x.Source = s.ReadString()
		case "width_px", "widthPx":
			s.AddField("width_px")
			x.WidthPx = s.ReadInt32()
		case "height_px", "heightPx":
			s.AddField("height_px")
			x.HeightPx = s.ReadInt32()
		case "width_text_scale", "widthTextScale":
			s.AddField("width_text_scale")
			x.WidthTextScale = s.ReadInt32()
		case "height_text_scale", "heightTextScale":
			s.AddField("height_text_scale")
			x.HeightTextScale = s.ReadInt32()
		case "data":
			s.AddField("data")
			x.Data = s.ReadBytes()
		case "data_fetch_type", "dataFetchType":
			s.AddField("data_fetch_type")
			x.DataFetchType.UnmarshalProtoJSON(s)
		}
	})
}

// UnmarshalJSON unmarshals the ImageData from JSON.
func (x *ImageData) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the SpaceData message to JSON.
func (x *SpaceData) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Reserved || s.HasField("reserved") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("reserved")
		s.WriteBool(x.Reserved)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the SpaceData to JSON.
func (x *SpaceData) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the SpaceData message from JSON.
func (x *SpaceData) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "reserved":
			s.AddField("reserved")
			x.Reserved = s.ReadBool()
		}
	})
}

// UnmarshalJSON unmarshals the SpaceData from JSON.
func (x *SpaceData) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

func (m *Paragraph) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Paragraph) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Paragraph) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Fixed {
		i--
		if m.Fixed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Alignment != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Alignment))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Lines) > 0 {
		for iNdEx := len(m.Lines) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Lines[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Line) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Line) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Line) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.RuneWidth != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.RuneWidth))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Boxes) > 0 {
		for iNdEx := len(m.Boxes) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Boxes[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Box) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Box) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Box) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if vtmsg, ok := m.Data.(interface {
		MarshalToSizedBufferVT([]byte) (int, error)
	}); ok {
		size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
	}
	if m.ContentType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.ContentType))
		i--
		dAtA[i] = 0x18
	}
	if m.LineCountHint != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.LineCountHint))
		i--
		dAtA[i] = 0x10
	}
	if m.RuneWidth != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.RuneWidth))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Box_TextData) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Box_TextData) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TextData != nil {
		size, err := m.TextData.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x4a
	} else {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Box_TextButtonData) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Box_TextButtonData) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TextButtonData != nil {
		size, err := m.TextButtonData.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x52
	} else {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Box_ImageData) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Box_ImageData) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ImageData != nil {
		size, err := m.ImageData.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x5a
	} else {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Box_SpaceData) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Box_SpaceData) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SpaceData != nil {
		size, err := m.SpaceData.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x62
	} else {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *TextData) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextData) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TextData) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Bgcolor != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Bgcolor))
		i--
		dAtA[i] = 0x18
	}
	if m.Fgcolor != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Fgcolor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TextButtonData) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextButtonData) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TextButtonData) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Command) > 0 {
		i -= len(m.Command)
		copy(dAtA[i:], m.Command)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Command)))
		i--
		dAtA[i] = 0x12
	}
	if m.TextData != nil {
		size, err := m.TextData.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImageData) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageData) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ImageData) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.DataFetchType != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.DataFetchType))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x52
	}
	if m.HeightTextScale != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.HeightTextScale))
		i--
		dAtA[i] = 0x28
	}
	if m.WidthTextScale != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.WidthTextScale))
		i--
		dAtA[i] = 0x20
	}
	if m.HeightPx != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.HeightPx))
		i--
		dAtA[i] = 0x18
	}
	if m.WidthPx != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.WidthPx))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpaceData) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceData) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SpaceData) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Reserved {
		i--
		if m.Reserved {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Paragraph) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Id))
	}
	if len(m.Lines) > 0 {
		for _, e := range m.Lines {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.Alignment != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Alignment))
	}
	if m.Fixed {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *Line) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Boxes) > 0 {
		for _, e := range m.Boxes {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.RuneWidth != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.RuneWidth))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Box) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuneWidth != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.RuneWidth))
	}
	if m.LineCountHint != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.LineCountHint))
	}
	if m.ContentType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.ContentType))
	}
	if vtmsg, ok := m.Data.(interface{ SizeVT() int }); ok {
		n += vtmsg.SizeVT()
	}
	n += len(m.unknownFields)
	return n
}

func (m *Box_TextData) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TextData != nil {
		l = m.TextData.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *Box_TextButtonData) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TextButtonData != nil {
		l = m.TextButtonData.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *Box_ImageData) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImageData != nil {
		l = m.ImageData.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *Box_SpaceData) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpaceData != nil {
		l = m.SpaceData.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *TextData) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Fgcolor != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Fgcolor))
	}
	if m.Bgcolor != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Bgcolor))
	}
	n += len(m.unknownFields)
	return n
}

func (m *TextButtonData) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TextData != nil {
		l = m.TextData.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ImageData) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.WidthPx != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.WidthPx))
	}
	if m.HeightPx != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.HeightPx))
	}
	if m.WidthTextScale != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.WidthTextScale))
	}
	if m.HeightTextScale != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.HeightTextScale))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.DataFetchType != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.DataFetchType))
	}
	n += len(m.unknownFields)
	return n
}

func (m *SpaceData) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reserved {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *Paragraph) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Paragraph: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Paragraph: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lines", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lines = append(m.Lines, &Line{})
			if err := m.Lines[len(m.Lines)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alignment", wireType)
			}
			m.Alignment = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alignment |= Alignment(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fixed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Line) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Line: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Line: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Boxes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Boxes = append(m.Boxes, &Box{})
			if err := m.Boxes[len(m.Boxes)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneWidth", wireType)
			}
			m.RuneWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuneWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Box) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Box: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Box: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneWidth", wireType)
			}
			m.RuneWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuneWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineCountHint", wireType)
			}
			m.LineCountHint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LineCountHint |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			m.ContentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentType |= ContentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Data.(*Box_TextData); ok {
				if err := oneof.TextData.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &TextData{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Data = &Box_TextData{TextData: v}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextButtonData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Data.(*Box_TextButtonData); ok {
				if err := oneof.TextButtonData.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &TextButtonData{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Data = &Box_TextButtonData{TextButtonData: v}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Data.(*Box_ImageData); ok {
				if err := oneof.ImageData.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &ImageData{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Data = &Box_ImageData{ImageData: v}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Data.(*Box_SpaceData); ok {
				if err := oneof.SpaceData.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &SpaceData{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Data = &Box_SpaceData{SpaceData: v}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextData) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fgcolor", wireType)
			}
			m.Fgcolor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fgcolor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bgcolor", wireType)
			}
			m.Bgcolor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bgcolor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextButtonData) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextButtonData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextButtonData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TextData == nil {
				m.TextData = &TextData{}
			}
			if err := m.TextData.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageData) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WidthPx", wireType)
			}
			m.WidthPx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WidthPx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeightPx", wireType)
			}
			m.HeightPx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeightPx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WidthTextScale", wireType)
			}
			m.WidthTextScale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WidthTextScale |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeightTextScale", wireType)
			}
			m.HeightTextScale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeightTextScale |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFetchType", wireType)
			}
			m.DataFetchType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataFetchType |= ImageFetchType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceData) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reserved = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
