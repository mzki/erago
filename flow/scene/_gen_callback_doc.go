// +build ignore

package main

import (
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
)

// This file generates list of callback funtions by
// parsing ast of files in this package.
//
// Parsed constants are tagged by comment:
//	// +callback :[scene_name]
//
// And each constants annotated by comment on same line:
//  const Const = "callback_name" // +arg_name -> return_name
//
// Example:
//
//	// +callback :title
//	const (
//		Constant1 = "callback_name1"
//		Constant2 = "callback_name2" // +number
//		Constant3 = "callback_name3" // +number -> bool
//
// It genenrates callback list
//
//  [title]
//	callback_name1()
//	callback_name2(number)
//	bool = callback_name3(number)
//
// TODO: new doc generator
// // +scene :scenename
// const (
//	 // +function: ret = {{.FuncName}}(arg)
//   // annotation text...
//	 Constant1 = "callback_name1"
//
//	 // +function: ret = {{.FuncName}}(arg)
//   // annotation text...
//	 Constant2 = "callback_name2"
// )

type callbacks []funcDecl

type funcDecl struct {
	// Suppose Scheme: ret = {{.Name}}(args) and Name: print,
	// FuncDecl generates complete definition of the funcion:
	//	 ret = print(args)

	Template string // template for the funcion definition
	Name     string // function name
	Doc      []string
}

const NamePlaceHolder = "{{.Name}}"

func (decl funcDecl) Definition() string {
	return strings.Replace(decl.Template, NamePlaceHolder, decl.Name, 1)
}

func main() {
	if err := ParseAST("./"); err != nil {
		panic(err)
	}
}

func ParseAST(dir string) error {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	callbacks := parseCallBacksFromAST(pkgs["scene"]) // NOTE: use package name directly
	err = writeAsPlainTxt("callback_list.txt", callbacks)
	// err = writeAsJson("callback_list.json", callbacks)
	return err
}

const SceneTag = "// +scene:"

func parseCallBacksFromAST(pkg *ast.Package) map[string]callbacks {
	callback_map := make(map[string]callbacks)

	for _, f := range pkg.Files {
		ast.Inspect(f, func(n ast.Node) bool {
			switch decl := n.(type) {
			case *ast.GenDecl:
				if decl.Tok != token.CONST {
					break
				}

				doc := decl.Doc
				if doc == nil || len(doc.List) == 0 {
					break
				}

				tag := doc.List[0].Text
				if !strings.Contains(tag, SceneTag) {
					break
				}

				sceneName := strings.TrimPrefix(tag, SceneTag)
				sceneName = strings.TrimSpace(sceneName)
				if len(sceneName) == 0 {
					// TODO: notify error with declaration line.
				}
				if _, has := callback_map[sceneName]; !has {
					callback_map[sceneName] = make(callbacks, 0, 4)
				}

				callback_map[sceneName] = addCallBacksFromSpecs(callback_map[sceneName], decl.Specs)
			}
			return true
		})
	}
	return callback_map
}

func addCallBacksFromSpecs(cs callbacks, specs []ast.Spec) callbacks {
	for _, spec := range specs {
		vs, ok := spec.(*ast.ValueSpec)
		if !ok {
			continue
		}

		func_decl, err := parseCallbackDoc(vs.Doc)
		if err != nil {
			log.Println(vs.Names[0].NamePos, err)
			continue
		}

		func_name := vs.Values[0].(*ast.BasicLit).Value
		func_name = strings.Trim(func_name, "\"")

		func_decl.Name = func_name
		cs = append(cs, func_decl)
	}
	return cs
}

const (
	CallbackFuncTag = "// +callback:"
)

func parseCallbackDoc(comments *ast.CommentGroup) (funcDecl, error) {
	if comments == nil {
		return funcDecl{}, errors.New("documentation is not found")
	}

	firstLine := comments.List[0].Text
	if ok := strings.HasPrefix(firstLine, CallbackFuncTag); !ok {
		return funcDecl{}, errors.New(CallbackFuncTag + " is not found")
	}

	definition := strings.TrimSpace(strings.TrimPrefix(firstLine, CallbackFuncTag))
	doc := make([]string, 0, 2)
	for _, com := range comments.List[1:] {
		line := strings.TrimPrefix(com.Text, "//")
		doc = append(doc, line)
	}
	return funcDecl{
		Template: definition,
		Doc:      doc,
	}, nil
}

const (
	DocIndentSpace = 2
)

func writeAsPlainTxt(file string, callbacks_list map[string]callbacks) error {
	fp, err := os.Create(file)
	if err != nil {
		return err
	}
	defer fp.Close()

	fmt.Fprintln(fp, `# Generated by gen_callback_doc.go, by parsing pakcage scene.

These callback functions must be prefixed "era." in the script file.
So callback function "event_title()" is defined "era.event_title()" in script file.

以下のcallback関数は、era.XXXという形式で、スクリプトファイル内に定義します。
例えば、"event_title()"という関数があったとき、スクリプト上では、"era.event_title()"と
いうように、定義します。

`)

	indent := strings.Repeat(" ", DocIndentSpace)

	for scene, functions := range callbacks_list {
		fmt.Fprintln(fp, "[scene: "+scene+"]\n")

		functions = append(makeDefaultCallback(scene), functions...)
		for _, f := range functions {
			fmt.Fprintln(fp, f.Definition())
			fmt.Fprintln(fp, "")
			for _, line := range f.Doc {
				fmt.Fprintln(fp, indent+line)
			}
			fmt.Fprintln(fp, "")
		}
		fmt.Fprintln(fp, "")
	}
	return nil
}

func makeDefaultCallback(scene_name string) callbacks {
	scene_decl := funcDecl{
		Template: "scene_" + scene_name + "()",
		Doc: strings.Split(` この関数は、もし定義されていれば、シーンの最も始めに呼ばれ、
 シーン全体の処理を置き換えます。
 この関数内では、必ず次のシーンを指定しなければならないことに注意してください。`, "\n"),
	}

	event_decl := funcDecl{
		Template: "event_" + scene_name + "_start()",
		Doc:      strings.Split(` この関数は、もし定義されていれば、シーンの始めに呼ばれます。`, "\n"),
	}

	return callbacks{scene_decl, event_decl}
}
